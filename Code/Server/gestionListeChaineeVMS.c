
/* Pour le cours : SIF1015
 * Travail : TP3
 * Session : AUT 2024
 * Étudiants:   Yoan Tremblay
 *              Nathan Pinard
 *              Derek Stevens
 *              Malyk Ratelle
 *              Yannick Lemire
 *
 *  gestionlisteChaineeVMS.c : 	Basé sur l'utilitaires Liste Chainee et CVS LINUX Automne 24 de François Meunier
 *  							avec modifications pour la gestion de communication client/serveur
 *
 */

#include "gestionListeChaineeVMS.h"
#include "gestionVMS.h"
#include <unistd.h>
/*extern sem_t semH,semQ,semC;*/
//Pointeur de tête de liste
extern struct noeudVM* head;
//Pointeur de queue de liste pour ajout rapide
extern struct noeudVM* queue;
// nombre de VM actives
extern int nbVM;

extern sem_t semNbVM, semQ, semH, semC;

struct client_FIFO_Info* getClientPathName(int client_pid);
void sendOutput(int client_fifo_fd, char const * msg);

//#######################################
//#
//# Affiche une série de retour de ligne pour "nettoyer" la console
//#
void cls(void){
	printf("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n");
	}

//#######################################
//#
//# Affiche un message et quitte le programme
//#
void error(const int exitcode, const char * message){
	printf("\n-------------------------\n%s\n",message);
	exit(exitcode);
	}
	
/* Sign Extend */
uint16_t sign_extend(uint16_t x, int bit_count)
{
    if ((x >> (bit_count - 1)) & 1) {
        x |= (0xFFFF << bit_count);
    }
    return x;
}

/* Swap */
uint16_t swap16(uint16_t x)
{
    return (x << 8) | (x >> 8);
}

/* Update Flags */
void update_flags(uint16_t reg[R_COUNT], uint16_t r)
{
    if (reg[r] == 0)
    {
        reg[R_COND] = FL_ZRO;
    }
    else if (reg[r] >> 15) /* a 1 in the left-most bit indicates negative */
    {
        reg[R_COND] = FL_NEG;
    }
    else
    {
        reg[R_COND] = FL_POS;
    }
}


/* Validation of an adress generated by a program  */
int validAdress(uint16_t * memory,uint16_t  offset, struct noeudVM * ptr, char accessType)
{
	
	if(((memory+offset) > (memory+65535)) || ((memory) > (memory+offset)) )
	{
		sem_wait(&semC);
		printf("\n Adresse invalide");
		sem_post(&semC);
		return 0; 
	}	
    if (accessType == 'W') { // validate if in code region
			if(((memory+offset) > (memory+ptr->VM.offsetDebutCode)) && ((memory+ptr->VM.offsetFinCode) > (memory+offset)))
			{
				sem_wait(&semC);
				printf("\n Adresse invalide en Write");
				sem_post(&semC);
				return 0;
			}				
	}		
	return 1;
}

/* Read Image File */
int read_image_file(uint16_t * memory, char* image_path,uint16_t * origin,  struct noeudVM * ptr)
{
	 char fich[200];
	 strcpy(fich,image_path);
	 
	 if(fich[strlen(fich)-1]=='\r')
	 	fich[strlen(fich)-1]='\0';
  	 FILE* file = fopen(fich, "rb");
 
    if (!file) { return 0; }
    /* the origin tells us where in memory to place the image */
   	*origin=0x3000;

    /* we know the maximum file size so we only need one fread */
    uint16_t max_read = UINT16_MAX - *origin;
    uint16_t* p = memory + *origin;
    ptr->VM.offsetDebutCode = *origin;
    size_t read = fread(p, sizeof(uint16_t), max_read, file);
    ptr->VM.offsetFinCode = *origin+read-1;
    ptr->VM.DimRamUsed = read;// Ram utilisee par la VM 
    /* swap to little endian ???? */
    while (read-- > 0)
    {
    //	printf("\n p * BIG = %x",*p);
       // *p = swap16(*p);
		// printf("\n p * LITTLE = %x",*p);
        ++p;
    }
    return 1;
}


/* Check Key */
uint16_t check_key()
{
    fd_set readfds;
    FD_ZERO(&readfds);
    FD_SET(STDIN_FILENO, &readfds);

    struct timeval timeout;
    timeout.tv_sec = 0;
    timeout.tv_usec = 0;
    return select(1, &readfds, NULL, NULL, &timeout) != 0;
}

/* Memory Access */
void mem_write(uint16_t * memory, uint16_t address, uint16_t val)
{
    memory[address] = val;
}

uint16_t mem_read( uint16_t * memory, uint16_t address)
{
    if (address == MR_KBSR)
    {
        if (check_key())
        {
            memory[MR_KBSR] = (1 << 15);
            memory[MR_KBDR] = getchar();
        }
        else
        {
            memory[MR_KBSR] = 0;
        }
    }
    return memory[address];
}

/* Input Buffering */
struct termios original_tio;

void disable_input_buffering()
{
    tcgetattr(STDIN_FILENO, &original_tio);
    struct termios new_tio = original_tio;
    new_tio.c_lflag &= ~ICANON & ~ECHO;
    tcsetattr(STDIN_FILENO, TCSANOW, &new_tio);
}

void restore_input_buffering()
{
    tcsetattr(STDIN_FILENO, TCSANOW, &original_tio);
}

/* Handle Interrupt */
void handle_interrupt(int signal)
{
    restore_input_buffering();
    printf("\n");
    exit(-2);
}
/* Fonction : Execute le fichier de code .olc3
 * Entrée : une struct contenant les arguments de l'appel
 * Sortie : un pointeur vers une struct nulle ou non
*/
void* executeFile(void* args){
	struct paramX* param = args;//Désérialisation des arguments
  	char sourcefname[100];

	int client_socket_fd = param->client_socket_fd;
	int p = param->boolPrint;
  	strcpy(sourcefname, param->fileName);
	free(param);

/* Memory Storage */
/* 65536 locations */
	uint16_t *  memory;
	uint16_t origin;
	uint16_t PC_START;
	
/* Register Storage */
	uint16_t reg[R_COUNT];
    struct noeudVM * ptr = findFreeVM();

    if(ptr == NULL) // Aucune VM libre 
    {
    	sendOutput(client_socket_fd, "Virtual Machine ajoutee\n");
    	ptr = addItem();
    }

	memory = ptr->VM.ptrDebutVM;
    if (!read_image_file(memory, sourcefname, &origin, ptr))
    {
    	char *msg = malloc(100*sizeof(char));
    	sprintf(msg, "Failed to load image: %s\n", sourcefname);
    	sendOutput(client_socket_fd, msg);
    	free(msg);
    	sem_post(&ptr->semN);
    	pthread_exit(0);
    }

	// Acquiring access to the VM
    ptr->VM.busy = 1;
	ptr->VM.tid = pthread_self(); // Doit récupérer le pthread ID directement puisque le TID réfère à une autre table
    sem_post(&ptr->semN);
    
    /* Setup */
    signal(SIGINT, handle_interrupt);
    disable_input_buffering();

    /* set the PC to starting position */
    /* at  ptr->VM.ptrDebutVM + 0x3000 is the default  */
    //enum { PC_START = origin };
    PC_START = origin;
    reg[R_PC] = PC_START;
    uint16_t instr;
    uint16_t op;
    int running = 1;
    while (running)
    {
    	pthread_testcancel();
        // FETCH
		if(validAdress(memory, reg[R_PC], ptr, 'R'))
		{
			instr = mem_read(memory, reg[R_PC]++);
		}
		else //invalid adress
		{
			running = 0;
			sendOutput(client_socket_fd, "Program abort memory out of bound\n");
			continue;
		}
		op = instr >> 12;
        switch (op)
        {
            case OP_ADD:
                // ADD
                {
                    // destination register (DR)
                    uint16_t r0 = (instr >> 9) & 0x7;
                    // first operand (SR1)
                    uint16_t r1 = (instr >> 6) & 0x7;
                    // whether we are in immediate mode
                    uint16_t imm_flag = (instr >> 5) & 0x1;
                
                    if (imm_flag)
                    {
                        uint16_t imm5 = sign_extend(instr & 0x1F, 5);
                        reg[r0] = reg[r1] + imm5;
                    }
                    else
                    {
                        uint16_t r2 = instr & 0x7;
                        reg[r0] = reg[r1] + reg[r2];
                        if(p){
                        	char *msg = malloc(100*sizeof(char));
                        	sprintf(msg, "add reg[r0] (sum) = %d\n", reg[r0]);
                        	sendOutput(client_socket_fd, msg);
                        	free(msg);
                        }
                    }
                    update_flags(reg, r0);
                }
                break;
            case OP_AND:
                // AND
                {
                    uint16_t r0 = (instr >> 9) & 0x7;
                    uint16_t r1 = (instr >> 6) & 0x7;
                    uint16_t imm_flag = (instr >> 5) & 0x1;
                
                    if (imm_flag)
                    {
                        uint16_t imm5 = sign_extend(instr & 0x1F, 5);
                        reg[r0] = reg[r1] & imm5;
                    }
                    else
                    {
                        uint16_t r2 = instr & 0x7;
                        reg[r0] = reg[r1] & reg[r2];
                    }
                    update_flags(reg, r0);
                }
                break;
            case OP_NOT:
                // NOT
                {
                    uint16_t r0 = (instr >> 9) & 0x7;
                    uint16_t r1 = (instr >> 6) & 0x7;
                
                    reg[r0] = ~reg[r1];
                    update_flags(reg, r0);
                }
                break;
            case OP_BR:
                // BR
                {
                    uint16_t pc_offset = sign_extend(instr & 0x1FF, 9);
                    uint16_t cond_flag = (instr >> 9) & 0x7;
                    if (cond_flag & reg[R_COND])
                    {
                        reg[R_PC] += pc_offset;
                    }
                }
                break;
            case OP_JMP:
                // JMP
                {
                    // Also handles RET
                    uint16_t r1 = (instr >> 6) & 0x7;
                    reg[R_PC] = reg[r1];
                }
                break;
            case OP_JSR:
                // JSR
                {
                    uint16_t long_flag = (instr >> 11) & 1;
                    reg[R_R7] = reg[R_PC];
                    if (long_flag)
                    {
                        uint16_t long_pc_offset = sign_extend(instr & 0x7FF, 11);
                        reg[R_PC] += long_pc_offset;  // JSR
                    }
                    else
                    {
                        uint16_t r1 = (instr >> 6) & 0x7;
                        reg[R_PC] = reg[r1]; // JSRR
                    }
                    break;
                }
                break;
            case OP_LD:
                // LD
				{
                    uint16_t r0 = (instr >> 9) & 0x7;
                    uint16_t pc_offset = sign_extend(instr & 0x1FF, 9);
					if(validAdress(memory, reg[R_PC]+ pc_offset, ptr, 'R'))
					{
						reg[r0] = mem_read(memory, reg[R_PC] + pc_offset); // valider adresse afficher message erreur mem et running = 0
						update_flags(reg, r0);
					}
					else //invalid adress
					{
						running = 0;
						sendOutput(client_socket_fd, "Program abort memory out of bound\n");
					}
				}
                break;
            case OP_LDI:
                // LDI
				{
                    // destination register (DR)
                    uint16_t r0 = (instr >> 9) & 0x7;
                    // PCoffset 9
                    uint16_t pc_offset = sign_extend(instr & 0x1FF, 9);
                    // add pc_offset to the current PC, look at that memory location to get the final address
					if(validAdress(memory, reg[R_PC]+ pc_offset, ptr, 'R'))
					{
						reg[r0] = mem_read(memory, mem_read(memory, reg[R_PC] + pc_offset)); // valider adresse afficher message erreur mem et running = 0
						update_flags(reg, r0);
					}
					else //invalid adress
					{
						running = 0;
						sendOutput(client_socket_fd, "Program abort memory out of bound\n");
					}
				}
                break;
            case OP_LDR:
                // LDR
				{
                    uint16_t r0 = (instr >> 9) & 0x7;
                    uint16_t r1 = (instr >> 6) & 0x7;
                    uint16_t offset = sign_extend(instr & 0x3F, 6);
					if(validAdress(memory, reg[r1]+ offset, ptr, 'R'))
					{
						reg[r0] = mem_read(memory, reg[r1] + offset); // valider adresse afficher message erreur mem et running = 0
						update_flags(reg, r0);
					}
					else //invalid adress
					{
						running = 0;
						sendOutput(client_socket_fd, "Program abort memory out of bound\n");
					}
				}
                break;
            case OP_LEA:
                 //LEA
                {
                    uint16_t r0 = (instr >> 9) & 0x7;
                    uint16_t pc_offset = sign_extend(instr & 0x1FF, 9);
                    reg[r0] = reg[R_PC] + pc_offset;
                    update_flags(reg, r0);
                }
                break;
            case OP_ST:
                // ST
				{
                    uint16_t r0 = (instr >> 9) & 0x7;
                    uint16_t pc_offset = sign_extend(instr & 0x1FF, 9);
					if(validAdress(memory, reg[R_PC]+ pc_offset, ptr, 'W'))
					{
						mem_write(memory, reg[R_PC] + pc_offset, reg[r0]); // valider adresse afficher message erreur mem et running = 0
					}
					else //invalid adress
					{
						running = 0;
						sendOutput(client_socket_fd, "Program abort memory out of bound or access violation\n");
					}                
				}
                break;
            case OP_STI:
                // STI
				{
                    uint16_t r0 = (instr >> 9) & 0x7;
                    uint16_t pc_offset = sign_extend(instr & 0x1FF, 9);
					if(validAdress(memory, reg[R_PC] + pc_offset, ptr, 'R'))
					{
						if(validAdress(memory, mem_read(memory, reg[R_PC] + pc_offset), ptr, 'W'))
						{
							mem_write(memory, mem_read(memory, reg[R_PC] + pc_offset), reg[r0]); // valider adresse afficher message erreur mem et running = 0
						}
						else //invalid adress
						{
							running = 0;
							sendOutput(client_socket_fd, "Program abort memory out of bound or access violation\n");
						}
					}
					else //invalid adress
					{
						running = 0;
						sendOutput(client_socket_fd, "Program abort memory out of bound\n");
					}						
				}
                break;
            case OP_STR:
                //STR
				{
                    uint16_t r0 = (instr >> 9) & 0x7;
                    uint16_t r1 = (instr >> 6) & 0x7;
                    uint16_t offset = sign_extend(instr & 0x3F, 6);
					if(validAdress(memory, reg[r1] + offset, ptr, 'W'))
					{
						mem_write(memory, reg[r1] + offset, reg[r0]); // valider adresse afficher message erreur mem et running = 0
					}
					else //invalid adress
					{
						running = 0;
						sendOutput(client_socket_fd, "Program abort memory out of bound or access violation\n");
					}                                
				}
                break;
            case OP_TRAP:
                // TRAP
                switch (instr & 0xFF)
                {
                    case TRAP_GETC:
                       // TRAP GETC
                        // read a single ASCII char
                        reg[R_R0] = (uint16_t)getchar();

                        break;
                    case TRAP_OUT:
                        // TRAP OUT
                        putc((char)reg[R_R0], stdout);
                        fflush(stdout);

                        break;
                    case TRAP_PUTS:
                        // TRAP PUTS
						{
                            // one char per word
                            uint16_t* c = memory + reg[R_R0]; // valider adresse afficher message erreur mem et running = 0
							if(validAdress(c, 0, ptr, 'R'))
							{
								while (*c)
								{
									putc((char)*c, stdout);
									++c; // valider adresse afficher message erreur mem et running = 0
									if(!validAdress(c, 0, ptr, 'R'))
									{
										running = 0;
										sendOutput(client_socket_fd, "Program abort memory out of bound\n");
										*c = 0;
									}     
								}
								fflush(stdout);
							}
							else //invalid adress
							{
								running = 0;
								sendOutput(client_socket_fd, "Program abort memory out of bound\n");
							}     
						}
                        break;
                    case TRAP_IN:
                        // TRAP IN
                        {
                    		sendOutput(client_socket_fd, "Enter a character\n");
                            char c = getchar();
                            putc(c, stdout);
                            reg[R_R0] = (uint16_t)c;
                        }
                        break;
                    case TRAP_PUTSP:
                        // TRAP PUTSP
							{
                            // one char per byte (two bytes per word)
                             //  here we need to swap back to
                             //  big endian format
                            uint16_t* c = memory + reg[R_R0]; // valider adresse afficher message erreur mem et running = 0
							if(validAdress(c, 0, ptr, 'R'))
							{
								while (*c)
								{
									char char1 = (*c) & 0xFF;
									putc(char1, stdout);
									char char2 = (*c) >> 8;

									if (char2) putc(char2, stdout);
									++c; // valider adresse afficher message erreur mem et running = 0
									if(!validAdress(c, 0, ptr, 'R'))
									{
										running = 0;
										sendOutput(client_socket_fd, "Program abort memory out of bound\n");
										*c = 0;
									}     
								}
								fflush(stdout);
							}
							else //invalid adress
							{
								running = 0;
								sendOutput(client_socket_fd, "Program abort memory out of bound\n");
							}     
						}
                        break;
                    case TRAP_HALT:
                        // TRAP HALT
                        sendOutput(client_socket_fd, "HALT\n");
                		running = 0;

                        break;
                }
                break;
            case OP_RES:
            case OP_RTI:
            default:
                // BAD OPCODE
                abort();
                break;
        }
    }
    /*initialisation des variables pour réutilisation*/
    sem_wait(&ptr->semN);
    ptr->VM.busy = 0;
    ptr->VM.DimRamUsed = 0;
    sem_post(&ptr->semN);
    restore_input_buffering();
	pthread_exit(0);
}

//#######################################
//# Recherche une VM libre dans la liste chaînée
//# ENTREE: 
//# RETOUR:	Un pointeur vers la premiere VM libre	
//# 		Retourne NULL dans le cas où aucune VM disponible
struct noeudVM * findFreeVM(){
	sem_wait(&semH);
	sem_wait(&semQ);
	//Si la liste est vide on ne trouve rien
	if ((head == NULL) && (queue == NULL)) {
		sem_post(&semQ);
		sem_post(&semH);
		return NULL;
	}
	sem_wait(&head->semN);
	struct noeudVM *ptr = head;

	sem_post(&semQ);
	sem_post(&semH);
	if (!ptr->VM.busy) // premier noeudVM voir si Not busy
		return ptr;
	do {
		if(ptr->suivant!=NULL){
			sem_wait(&(ptr->suivant->semN));
		}
		else{
			sem_post(&(ptr->semN));
			return NULL;
		}
		//on se garde un copie temporaire avant de changer ptr pour pouvoir post le semN
		struct noeudVM* temp = ptr;
		ptr=ptr->suivant;
		sem_post(&(temp->semN));
	}while(ptr->VM.busy);

	return ptr;
}

//#######################################
//#
//# Recherche le PRÉDÉCESSEUR d'un item dans la liste chaînée
//# ENTREE: Numéro de la ligne a supprimer
//# RETOUR:	Le pointeur vers le prédécesseur est retourné		
//# 		Retourne NULL dans le cas où l'item est introuvable
//#
struct noeudVM * findPrev(const int no){
	//La liste est vide 
	if ((head==NULL)&&(queue==NULL)) return NULL;

	//Pointeur de navigation

    sem_wait(&head->semN);
	struct noeudVM * ptr = head;

	if(ptr->suivant!=NULL) {
		sem_wait(&ptr->suivant->semN);
	}else {
		sem_post(&ptr->semN);
		return NULL;
	}
	//Si le prochain n'est pas celui recherché on boucle
	while(ptr->suivant->VM.noVM!=no){
		//on se garde un variable temporaire du noeud pour pouvoir poster le sémaphore plus tard
		struct noeudVM* temp = ptr;
		ptr=ptr->suivant;
		sem_post(&temp->semN);
		if(ptr->suivant!=NULL) {
			sem_wait(&ptr->suivant->semN);
		}else {
			//Dans le cas ou le suivant est null, il n'y a aucune vm avec le numéro demandé
			sem_post(&ptr->semN);
			return NULL;
		}
	}
	sem_post(&ptr->suivant->semN);
	return ptr;
}

//#####################################################
//# Ajoute un noeud a la fin de la liste chaînée de VM
//# ENTREE: 
//#	RETOUR: ptr sur la VM ajoutee 
struct noeudVM* addItem(){
	//Création de l'enregistrement en mémoire
	struct noeudVM* ni = (struct noeudVM*)malloc(sizeof(struct noeudVM));
	//Affectation des valeurs des champs
	sem_wait(&semNbVM);
	ni->VM.noVM	= ++nbVM;
	sem_post(&semNbVM);
	ni->VM.busy	= 0;
	ni->VM.DimRam	= 65536;
	ni->VM.DimRamUsed	= 0;
	ni->VM.tid	= pthread_self(); // # du process ou d'un thread
	ni->VM.ptrDebutVM = (unsigned short*)malloc(sizeof(unsigned short)*65536);
	sem_init(&ni->semN, 0, 1);
	sem_wait(&semH);
	sem_wait(&semQ);
	if ((head == NULL) && (queue == NULL)){//liste vide
	  	ni->suivant= NULL;
	  	queue = head = ni;
		sem_wait(&ni->semN);
		sem_post(&semH);
		sem_post(&semQ);
	  	return ni;
	}
	sem_wait(&queue->semN);
	sem_post(&semH);
	struct noeudVM* tptr = queue;
	ni->suivant= NULL;
	queue = ni;
	tptr->suivant = ni;
	sem_wait(&ni->semN);
	sem_post(&tptr->semN);
	sem_post(&semQ);
	return queue;
}

//#######################################
//# Retire un item de la liste chaînée en exclusion mutuelle
//# ENTREE: noVM: numéro du noeud a retirer 
void* removeItem(void* args){
	struct paramE* param = args;
  	int const noVM = param -> noVM;
	free(param);
	struct noeudVM * ptr;
	struct noeudVM * tptr;
	struct noeudVM * optr;

	sem_wait(&semH);
	sem_wait(&semQ);
	//Vérification sommaire (noVM>0 et liste non vide)	
	if ((noVM<1)||((head==NULL)&&(queue==NULL)))
    {
		sem_post(&semH);
		sem_post(&semQ);
		return NULL;
    }

	//Pointeur de recherche
	if(noVM==1){
        sem_wait(&head->semN);
		ptr = head; // suppression du premier element de la liste
	}
	else{
		ptr = findPrev(noVM);
	}
	//L'item a été trouvé
	if (ptr!=NULL) {
		if(noVM != 1 && ptr->suivant->VM.busy) // ne pas supprimer une VM busy
		{
			sem_post(&ptr->semN);
			sem_post(&semH);
			sem_post(&semQ);
			return NULL;
		}
		// Memorisation du pointeur de l'item en cours de suppression
		// Ajustement des pointeurs
		if((head == ptr) && (noVM==1)) // suppression de l'element de tete
		{
			if(ptr->VM.busy) // ne pas supprimer une VM busy
			{
				sem_post(&ptr->semN);
				sem_post(&semH);
				sem_post(&semQ);
				return NULL;
			}
			sem_wait(&semNbVM);
			nbVM--;
			sem_post(&semNbVM);
			sem_t temp = ptr->semN;
			if(head==queue) // un seul element dans la liste
			{
				free(ptr->VM.ptrDebutVM);
				free(ptr);
                sem_post(&temp);
				queue = head = NULL;
				sem_post(&semH);
				sem_post(&semQ);
				return NULL;
			}
			sem_wait(&ptr->suivant->semN);
			tptr = ptr->suivant;
			head = tptr;
			free(ptr->VM.ptrDebutVM);
			free(ptr);
			sem_post(&temp);

		}
		else if (queue==ptr->suivant) // suppression de l'element de queue
		{
			sem_wait(&semNbVM);
			nbVM--;
			sem_post(&semNbVM);

			sem_wait(&ptr->suivant->semN);
			sem_t temp = ptr->suivant->semN;
			sem_post(&semH);
			queue=ptr;
			sem_post(&semQ);

			free(ptr->suivant->VM.ptrDebutVM);
			free(ptr->suivant);
			ptr->suivant=NULL;
            sem_post(&temp);
            sem_post(&ptr->semN);
			return NULL;
		}
		else // suppression d'un element dans la liste
		{
			sem_wait(&semNbVM);
			nbVM--;
			sem_post(&semNbVM);

			sem_wait(&ptr->suivant->semN);
			sem_t temp = ptr->suivant->semN;
			optr = ptr->suivant;
			sem_wait(&ptr->suivant->suivant->semN);
			ptr->suivant = ptr->suivant->suivant;
			tptr = ptr->suivant;
			free(optr->VM.ptrDebutVM);
			free(optr);
            sem_post(&temp);
            sem_post(&ptr->semN);
		}

		sem_post(&semH);
		sem_post(&semQ);

		while (tptr!=NULL){ // ajustement des numeros de VM
			//Est-ce le prédécesseur de l'item recherché?
			tptr->VM.noVM--;

			if(tptr->suivant == NULL) break;
			//Déplacement du pointeur de navigation
			struct noeudVM* temp = tptr;
			sem_wait(&tptr->suivant->semN);
			tptr=tptr->suivant;
            sem_post(&temp->semN);
		}
		sem_post(&tptr->semN);
	} else {
		sem_post(&semH);
		sem_post(&semQ);
	}
    return NULL;
}

//#######################################
//#
//# Affiche les items dont le numéro séquentiel est compris dans une plage
//#
void* listItems(void* args){
	//Désérialisation des arguments
	struct paramL* param = args;
	struct noeudVM * ptr = NULL;
    int start = param->nStart;
    int end = param->nEnd;
	int client_socket_fd = param->client_socket_fd;

	free(param);

	struct rusage  usage;

	//Affichage des entêtes de colonnes
	sendOutput(client_socket_fd, "noVM  Busy?	tid 	TempsCPU(us)		DimRam	DimRamUsed	Adr. Debut VM\n");
	sendOutput(client_socket_fd, "===========================================================================\n");

    sem_wait(&semH);
	if(head == NULL) {
		sem_post(&semH);
	}else {
		sem_wait(&head->semN);
		ptr = head;
		sem_post(&semH);

		while (ptr!=NULL){
			if (ptr->VM.noVM>end) break; //L'ensemble des vm de l'intervale sont passée
			//L'item a un numéro séquentiel dans l'interval défini
			if (ptr->VM.noVM>=start){
				if(ptr->VM.busy){
					getrusage(RUSAGE_SELF,&usage);
					char *msg = malloc(150*sizeof(char));
					sprintf(msg, "%d \t %d \t %ld	\t %ld \t %d \t %d \t %p\n",
						ptr->VM.noVM,ptr->VM.busy, ptr->VM.tid, usage.ru_utime.tv_sec,
						ptr->VM.DimRam, ptr->VM.DimRamUsed, ptr->VM.ptrDebutVM);

					sendOutput(client_socket_fd, msg);
					free(msg);
				}
				else // not busy
				{
					char *msg = malloc(150*sizeof(char));
					sprintf(msg, "%d \t %d \t %s	\t %d	\t %d \t %d \t %p\n",
						ptr->VM.noVM,0, "##############", 0, 65536, 0, ptr->VM.ptrDebutVM);

					sendOutput(client_socket_fd, msg);
					free(msg);
				}
			}

			if(ptr->suivant==NULL) break;
			//On garde une copie de ptr pour pouvoir libéré son sémaphore
			struct noeudVM* optr = ptr;
			sem_wait(&(ptr->suivant->semN));
			ptr = ptr->suivant;
			sem_post(&(optr->semN));
		}
		sem_post(&ptr->semN);
	}
	//Affichage des pieds de colonnes
	sendOutput(client_socket_fd, "===========================================================================\n");
	pthread_exit(0);
}

//#######################################
//#
//# Envoyer une commande à la console (commande B et P)
void* sendCommand(void* args) {
	char command[100];
	struct paramCommand* param = args;
	int client_socket_fd = param->client_socket_fd;
	strcpy(command, param->command);

	free(param);

	const int sfd = dup(1);

	sem_wait(&semC);
	if(dup2(client_socket_fd, 1) == -1) {
		sem_post(&semC);
		pthread_exit(0);
	}

	system(command);
	if(dup2(sfd, 1) != -1)
		close(sfd);
	sem_post(&semC);

	pthread_exit(0);
}

//#######################################
//#
//# Kill un process en execution threadee sur une VM (commande K)
//#
void* killThread(void* args){
	struct paramK* ptr = args;
	pthread_cancel(ptr->tid);
	free(ptr);
	pthread_exit(0);
}

/* Fonction : Envoyer le socket client et le message à la console en exclusion mutuelle
 * Entrée : socket client et le message à afficher
 * Sortie : rien
*/
void sendOutput(int client_socket_fd, char const * msg) {
	sem_wait(&semC); // Exclusion de la console
	const int sfd = dup(1);

	if(dup2(client_socket_fd, 1) == -1) { // Si dup2 est valable ferme la FIFO client et sort
		pthread_exit(0);
	}

	printf("%s", msg); // sinon affiche le msg
	if(dup2(sfd, 1) != -1) // si sfd est ouvert
		close(sfd);

	sem_post(&semC);// Libère la console
}
